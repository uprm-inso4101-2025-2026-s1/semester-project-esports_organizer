= Bracket Team Visualization Documentation
:toc:
:toclevels: 3 
:sectnums:

== Overview

The 'simulateTournamentBrackets' function simulates a tournament using Runbracket from MatchProgression, where it uses single elimination Brackets, this simulates the different rounds, including the final. The 'getTournamentData' function uses assignBrackets to get the initial teams and then simulates the tournament rounds in simulateTournamentBrackets. Then it returns the data in a structured format for visualization.

== Function Signatures

[source,javascript]
----
export function simulateTournamentBrackets(teams) {
  // Implementation goes here
}
----
[source,javascript]
----
export function getTournamentData(teams) {
  // Implementation goes here
}
----

=== Parameters

* 'Brackets' ('Array<Array<Team>>'): A 2D array containing team objects organized in brackets.
** Each team object must have 'name' and 'score' properties.
** The array structure supports multiple brackets that will be flattened.

=== Returns

* 'Array<Team>': Returns an array of teams sorted by their elimination order, with the champion as the last element.
* 'Object': Returns an object containing the tournament rounds and the champion team.
** 'rounds' ('Array<Team>'): An array of rounds, each containing an array of teams that participated in that round.
** 'champion' ('Team'): The team that won the tournament.

== Dependencies

* 'MatchProgression': The module responsible for managing the state and progression of the tournament matches.
* 'TournamentRegistration': A function that organizes teams into brackets for the tournament.

=== Required Team Structure

Team objects must implement the following interface:

[source,javascript]
----
export interface Team {
    name: string;
    score: number;
    // Additional properties exist, but are not required for this function
}
----

== Function Logic

=== simulateTournamentBrackets

The function performs the following steps:
1. *Input Validation*: Checks if the input array is valid and contains at least 2 teams
2. *Tournament Simulation*: Uses the 'runBracket' function to simulate the tournament rounds until a champion is determined.
3. *Round Tracking*: Collects the state of the tournament after each round for visualization purposes.
4. *Result Compilation*: Returns an object containing all rounds and the champion team.

=== getTournamentData

The function performs the following steps:
1. *Bracket Assignment*: Calls 'assignBrackets' to have all the teams that are assigned in the tournament brackets.
2. *Tournament Data Retrieval*: Calls 'simulateTournamentBrackets' to simulate the tournament and retrieve the results.
3. *Data Structuring*: Formats the retrieved data into a structured format suitable for visualization.

== Important Considerations

* The team objects must have at least 'name' and 'score' properties for the functions to work correctly
* Ensure that the team objects passed to these functions conform to the required structure.
* The tournament simulation is based on single-elimination rules, where a team is eliminated after a single loss.

== Error Handling

* The functions include error handling to manage invalid inputs.
* Descriptive error messages are provided to help identify issues with the input data.

== Example Usage

[source,javascript]

----
import { getTournamentData } from "./BracketTeamVisualization";

const teams = [
  { name: "Team A", score: 0 },
  { name: "Team B", score: 0 },
  { name: "Team C", score: 0 },
  { name: "Team D", score: 0 }
];

const tournamentData = getTournamentData(teams);
console.log(tournamentData);
// Output will show the rounds and the champion team
----

=== Example Output Structure

[source,json]
----
{
  rounds: [
    [ { name: "Team A", score: 1 }, { name: "Team B", score: 0 }, ... ], // Round 1
    [ { name: "Team A", score: 1 }, { name: "Team C", score: 0 }, ... ], // Round 2
    ...
  ],
  champion: { name: "Team A", score: 1 }
}
----  

=== Explanation of Output

* The output structure includes an array of rounds and the champion team, providing a clear view of the tournament progression.
* Each round contains the teams that participated in that round, along with their scores.
* The champion team is the last remaining team after all rounds have been completed.

== Usage example in a React Component

[source,jsx]
----
import React from 'react';
import { getTournamentData } from './BracketTeamVisualization';

const TournamentComponent = () => {
  const tournamentData = getTournamentData();

  return (
    <div>
      <h1>Tournament Results</h1>
      <h2>Champion: {tournamentData.champion.name}</h2>
      <h3>Rounds:</h3>
      <ul>
        {tournamentData.rounds.map((round, index) => (
          <li key={index}>
            Round {index + 1}:
            <ul>
              {round.map((team, i) => (
                <li key={i}>{team.name} (Score: {team.score})</li>
              ))}
            </ul>
          </li>
        ))}
      </ul>
    </div>
  );
};

export default TournamentComponent;
----

* This example demonstrates how to integrate the tournament data into a React component for displaying
in a tournament visualization.

== Notes 

* The functions are designed to be modular and reusable, allowing for easy integration into different parts of an application.
* Ensure that the necessary dependencies are correctly imported and available in the environment where these functions are used.

== Limitations

* Simulates all the rounds in a single function call, which may not be suitable for real-time applications where match results are updated dynamically.
* The functions assume that the input data is well-formed and may not handle all edge cases, such as duplicate team names or invalid scores.

== Extra information

* The tournament simulation can be customized by modifying the input data or the functions themselves.

== Conclusion

The 'simulateTournamentBrackets' and 'getTournamentData' functions provide a quick way to simulate a single-elimination tournament and obtain the data from it for visualization in the application.