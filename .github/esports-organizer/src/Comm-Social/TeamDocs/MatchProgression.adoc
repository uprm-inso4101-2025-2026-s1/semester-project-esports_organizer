= Bracket Tournament System Documentation
:toc: left
:toclevels: 3

== Overview

The bracket tournament system is a JavaScript module that simulates and manages single-elimination tournaments. It takes an array of teams and runs them through a bracket-style competition until a champion is determined.

== Dependencies

=== Required Imports

[source,javascript]
----
import Bracket from "../database/examples/Brackets.js";
import Team from "../database/examples/Teams.js";
----

* `Bracket`: Manages the tournament bracket structure and match progression
* `Team`: Represents individual teams with properties like `id`, `name`, and `score`

== Main Function: runBracket

=== Function Signature

[source,javascript]
----
export function runBracket(teams)
----

=== Parameters

* `teams` (Array<Team>): Array of team objects with `name` and `score` properties

=== Returns

* `Object` containing:
  * `results`: Array of winners/losers in order of elimination (last element is champion)
  * `rounds`: Array containing matchups for each round of the tournament

=== Error Handling

* Throws `Error` if:
  * `teams` is not an array
  * Fewer than 2 teams are provided

== Algorithm Flow

=== 1. Initialization

[source,javascript]
----
const bracket = new Bracket(teams);
bracket.createInitialMatches();
----

* Creates a new bracket instance with the provided teams
* Sets up initial matches based on the team list

=== 2. Tournament Loop

The main loop continues until all matches are completed:

[source,javascript]
----
while (bracket.matches && bracket.matches.size > 0)
----

==== For Each Round

* Logs current round number
* Converts current matches from Map to Array for processing
* Stores current round matches in `rounds` array for final output

=== 3. Match Processing

==== Team Resolution

* Converts team IDs to full team objects if necessary
* Handles "BYE" situations where a team may not have an opponent

[source,javascript]
----
if (typeof player1 === "string") {
  // Find full team object by ID
}
if (typeof player2 === "string") {
  // Handle potential BYE situation
}
----

==== Validation

* Ensures both players exist and have valid IDs
* Handles cases where player2 might be null (BYE)

==== BYE Handling

If a team has no opponent (BYE), they advance automatically:

[source,javascript]
----
if (!player2) {
  console.log(`${player1.name} advances automatically (BYE)`);
  bracket.recordResult(matchId, player1.id);
  continue;
}
----

=== 4. Match Simulation

==== Score Generation

* Generates random scores for testing purposes:
  * `score1 = Math.round(Math.random() * 150)`
  * `score2 = Math.round(Math.random() * 150)`

==== Winner Determination

1. *Higher Score Wins*: Team with higher randomly generated score wins
2. *Tie Breaker*: If scores are equal, randomly selects winner

[source,javascript]
----
if (score1 > score2) {
  // player1 wins, player2 eliminated
} else if (score2 > score1) {
  // player2 wins, player1 eliminated
} else {
  // Random tie breaker
}
----

==== Result Recording

* Records winner using `bracket.recordResult(matchId, winnerId)`
* Adds losing team to `finalTeamList` (elimination order)

=== 5. Round Progression

[source,javascript]
----
bracket.matches = new Map(bracket.nextRoundMatches);
bracket.nextRoundMatches.clear();
round++;
----

* Moves to next round matches
* Clears the next round matches container
* Increments round counter

=== 6. Tournament Completion

==== Champion Determination

[source,javascript]
----
const finalWinnerId = bracket._winnersCurrentRound?.[0];
const finalWinner = teams.find(t => t.id === finalWinnerId);
finalTeamList.push(finalWinner);
----

* Retrieves the final winner from bracket's winners list
* Adds champion as the last element in `finalTeamList`

== Data Structures

=== Bracket Object

The Bracket class manages:
* Current matches (Map)
* Next round matches (Map)
* Winner tracking
* Match result recording

=== Team Object

Expected structure:
[source,javascript]
----
{
  id: string | number,
  name: string,
  score: number
}
----

=== Output Structure

[source,javascript]
----
{
  results: [ // Elimination order: first eliminated -> champion
    Team,    // First team eliminated
    Team,    // Second team eliminated
    ...,
    Team     // Champion (last element)
  ],
  rounds: [  // Tournament progression
    [        // Round 1
      [matchId1, {player1: Team, player2: Team}],
      [matchId2, {player1: Team, player2: Team}],
      ...
    ],
    [        // Round 2
      ...
    ]
  ]
}
----

== Console Output

The function provides detailed console logging:

* Round headers: `--- Round X ---`
* Match results: `Team A (score) vs Team B (score)`
* Winner announcements: `Winner: Team Name`
* BYE notifications: `Team advances automatically (BYE)`
* Tie resolutions: `Tie! Randomly selected winner: Team Name`
* Final champion: `Champion: Team Name`

== Key Features

=== Automatic BYE Handling
* Teams without opponents automatically advance
* Common in tournaments with non-power-of-2 team counts

=== Error Resilience
* Validates team objects before processing
* Continues processing even if some teams are missing
* Provides warning messages for potential issues

=== Flexible Team Resolution
* Can handle both team objects and team IDs
* Resolves team references dynamically

=== Test-Friendly
* Uses random scoring for demonstration
* Easy to replace with real scoring logic

== Usage Example

[source,javascript]
----
const teams = [
  { id: 1, name: "Team A", score: 0 },
  { id: 2, name: "Team B", score: 0 },
  { id: 3, name: "Team C", score: 0 },
  { id: 4, name: "Team D", score: 0 }
];

const tournamentResults = runBracket(teams);
console.log("Elimination order:", tournamentResults.results.map(t => t.name));
console.log("Number of rounds:", tournamentResults.rounds.length);
----

== Limitations & TODO Items

* Currently uses random scores (marked for replacement)
* No organizer input for real results
* No support for different bracket types (double elimination, etc.)