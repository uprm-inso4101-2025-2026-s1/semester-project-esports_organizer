== Application of Topics

=== Algebras and Closure Under Operations

The project demonstrates algebraic closure through refined function signatures across multiple domains. Event and Team classes evolved from long parameter lists to single initializer objects with implicit defaults, ensuring valid object states. Tournament bracket generation implements closure through the ⁠ generateBrackets(tournament) → BracketStructure | Failure ⁠ function, which takes tournament parameters and returns a complete bracket structure or explicit failure state.

=== Agile Practices

Following Scrum methodology with bi-weekly sprints, the team organized around specialized roles including Managers, Team Leaders, and Development Teams (Database/Backend, Events, Profiles, Social Features, UI). Weekly ceremonies included sprint planning, progress reviews, and retrospectives. GitHub issues tracked feature development through branching and pull requests. This structure enabled continuous delivery of backend features and improved cross-team communication.

[.hl-green]#Agile is a software development approach which prioritized delivering working software in
small, frequent iterations while adapting to feedback such as changing system requirement or
user necessities. Agile encourages continuous collaboration, constant improvement and
incremental delivery. Our team follows the scrum methodology, which structures development
into bi-weekly cycles called sprints. After each sprint it is intended to have a potentially
shippable increment of the project.#

[.hl-green]#Team Roles#

• [.hl-green]#⁠  ⁠Managers: Ensures the scrum process is followed and manages the whole team.#
• [.hl-green]#⁠  ⁠Team Leaders: They coordinate weekly meetings, verify and approve issues before the managers view them and are up to date with the achievements of every member on their team.#
• [.hl-green]#⁠  ⁠Development Teams: Database and Backend, events and notifications, Profiles, social features, and UI teams in charge of developing the frontend and backend tasks.#



=== Decision-Making Processes

The team applied systematic evaluation methods for technical choices, such as the communication platform selection comparing Email versus Discord. Using weighted scoring matrices based on non-functional requirements (speed, ease of use, organization, scalability), Discord was selected with a score of 1.8 versus Email's 0.4. Similar evaluation processes were used for database design and architecture decisions.

[.hl-green]#To make an informed decision, both options were compared using Non-Functional Requirements (NFRs). The qualitative attributes of a system rather than its specific functions.#
[.hl-green]#The chosen criteria were:#

[.hl-green]#Speed of Communication - How fast users can exchange information.#

[.hl-green]#Ease of Use - How intuitive and accessible the platform is for all team members.#

[.hl-green]#Information Organization - How effectively messages and files can be structured and retrieved later.#

[.hl-green]#Scalability - How easily the platform can handle team growth in members, channels, and activities.#

=== Process Modeling

Petri nets modeled competing processes in tournament registration, particularly for limited slot allocation. Sequence diagrams illustrated tournament lifecycle interactions between hosts and participants. State charts defined tournament progression through creation, registration, match progression, and completion states.

[.hl-green]#Petri Nets help visualize how different backend functions interact dynamically within the tournament system.#

[.hl-green]#In our project, Petri Nets work as graphical representations of workflows inside the backend system,for tournament creation, registration, and progression. Each place represents a specific system state, while each transition models a backend function or event triggered by user or system actions.#

=== Real-Time System Design

The implementation uses Firebase's real-time capabilities with React state management for live bracket updates. Cloud Firestore's ⁠ onSnapshot() ⁠ listeners provide immediate data synchronization, while React's ⁠ useEffect ⁠ and ⁠ useState ⁠ hooks manage component state updates. This enables automatic bracket propagation when match results change.

[.hl-green]#he real-time updating feature ensures that tournament brackets in the eSports web app stay synchronized across all users without requiring manual refreshes.#

=== Tournament Algorithms

Single elimination bracket generation implements mathematical models using power-of-two calculations, bye allocations, and balanced binary tree structures. The system handles various tournament formats with algorithms for participant counting, round calculation (⁠ ceiling(log2 n) ⁠), and fair seeding through random shuffling or rank-based sorting.

=== Diagrams

%% App source files
class App {
App.jsx
}
class Main {
main.jsx
}
class Team {
team.js
}
class CommSocial {
Comm-Social/
}
class Components {
components/
}
class Pages {
pages/
}
class Services {
services/
}
class Database {
database/
}
class Lib {
lib/
}
class Events {
events/
}
class Functions {
functions/
}

App --> Main : "bootstrap"
App --> Team : "imports data"
App --> Components : "uses UI"
App --> Pages : "routes to"
Pages --> Components : "compose"
Services --> Database : "reads/writes"
Functions --> Events : "handles triggers"
Lib --> Database : "utils"
CommSocial --> Pages : "community features"
Events --> Services : "publishes events"
....

App bootstraps Main and pulls in domain models (Team, Events), UI (Components, Pages, CommSocial), logic (Services, Functions), persistence (Database, Lib). Arrows indicate directional dependencies (e.g., Pages compose Components, Services read/write Database, Functions handle event triggers).

In practice this means user interactions flow from Pages -> Services -> Database, yielding clear separation of concerns, easier testing, and safer evolution of UI and storage/persistence layers.