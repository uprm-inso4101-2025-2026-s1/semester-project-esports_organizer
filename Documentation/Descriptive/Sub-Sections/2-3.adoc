== 2.3 Implementation

[.hl-yellow]#The implementation stage describes how the system realizes the domain phenomena introduced in Section 2.2. Instead of focusing on the “platform”, this section explains how actions in the domain—such as updating a player’s visibility, retrieving event participation, or assigning badges—become concrete behaviors implemented by software components.#  

[.hl-green]#During Milestone 2, the Profiles module evolved from an abstract domain concept (“players have identity, visibility, and participation history”) into a working set of coordinated components. The goal is not just to implement features but to reflect the real behaviors observed in the gaming ecosystem the team studied.#  

[.hl-green]#A good way to understand this is to imagine walking with a friend to the university cafeteria while explaining what the system actually *does* when a player edits their profile. “Mira, cuando Liam updates his profile picture or hides his stats, that’s not just a button on the screen. That action travels through several components—first the React UI, then the backend API, then Firestore. Each step mirrors a behavior we saw in the domain: identity, visibility, and participation. The software simply gives those behaviors a place to live.”#  

The **software architecture** reflects how domain-level concepts transform into operational modules:

* [.hl-yellow]#Authentication ensures that only valid users can create, modify, or participate in events—mirroring the domain requirement for verified organizers and participants.#  
* [.hl-yellow]#User profiles are stored persistently, reflecting the domain notion of a “player identity” with attributes that others may see or that the player may choose to hide.#  
* [.hl-green]#The Profiles module (implemented using Node.js / Express) acts as the operational expression of domain actions such as “modify profile”, “request participation history”, or “toggle visibility”.#  
* [.hl-green]#The React client is the medium through which players perform these behaviors. When the player interacts with the UI, they are essentially causing a domain action to move through modules until the system fulfills it.#  
* [.hl-green]#Badge and Privacy Control modules correspond to phenomena such as reputation, privacy preferences, and player-to-player visibility, which emerged naturally during domain exploration.#  

[.hl-green]#In this context, the architecture diagram is not meant to be a strict engineering schematic, but rather a conceptual sketch of how domain behaviors travel through the system. To avoid confusion (as noted in the professor’s feedback), each type of element in the diagram corresponds to a specific category:#  

[.hl-green]#*Rectangles:* Functional modules that carry out domain operations (Profiles, Badge Module, Privacy Control).#  
[.hl-green]#*External-service rectangles:* Components outside our system (Firebase Auth, Firestore) that support authentication or persistence.#  
[.hl-green]#*Solid arrows:* Flows that represent domain actions being executed—such as storing updated profile data, reading badges, or toggling visibility.#

image::Descriptive/Sub-Sections/profiles_architecture.svg[align=center]
[.text-center]
Figure 2.3 - Profiles Module Architecture (Milestone 2)

[.hl-green]#Thinking again in “cafetería terms”: When Alex wants to check his past tournaments, the system behaves like a small conversation happening behind the scenes. React asks Express, Express checks Firestore, Firestore returns the data, and Express replies. This small chain of interactions corresponds directly to the domain’s requirement to make event results available even after tournaments conclude.#  

=== Realization of Domain Behaviors

The **software design** explains how each phenomenon in the domain becomes a concrete operation:

* **Authentication**  
  [.hl-yellow]#Reflects the domain restriction that only registered users can create or modify events or profiles.#

* **Profile Management**  
  [.hl-green]#Represents the player entity described in the domain. Updating or viewing a profile is not merely a UI action—it reflects the domain behavior of identifying players, referencing them in events, and ensuring data consistency.#  

* **Participation Retrieval**  
  [.hl-green]#Supports the requirement that results and participation remain visible and traceable, enabling rankings, statistics, and post-event visibility.#  

* **Badge & Visibility Controls**  
  [.hl-green]#Express aspects of player behavior such as reputation, privacy, or recognition available in real gaming communities, which surfaced during persona and field exploration.#

'''

=== 2.3.1 Selected Fragments of the Implementation

[.hl-yellow]#Selected fragments appear only to clarify how domain behaviors become implemented actions. They are not included merely for displaying code but for illustrating how the system operationalizes the phenomena discussed in Section 2.2.#  

[.hl-green]#The following fragment corresponds to the behavior “view a player’s past participation”, which aligns with the domain requirement ensuring that event results and participation remain accessible for ranking and visualization.#  

[source,js]
----
async function getParticipatedTournaments() {
    const querySnapshot = await getDocs(collection(db, "User"));

    const User = querySnapshot.docs.map((doc) => ({
      id: doc.id,
      ...doc.data()
    }));

    return User;
}
----

[.hl-green]#Seen from a domain perspective, this function is not “just fetching documents”. It represents the idea that players leave traces of participation behind them, and the system must preserve that history so it can be referenced by rankings, organizers, or other players.#  

[.hl-green]#The next code selection reflects domain actions related to players modifying their identity, adjusting visibility, or updating personal attributes—real behaviors that emerged clearly during persona and scenario analysis.#  

[source,js]
----
export async function saveProfile(profileData) { ... }
export async function getProfile(email) { ... }
export async function updateProfile(email, updates) { ... }
----

[.hl-green]#These operations embody the concept that “a player in the domain has persistent identity data that evolves over time”. Each function ensures integrity via timestamps, validating that the system remains consistent even as players make changes across tournaments or communities.#  

[.hl-green]#This alignment between domain concepts and implementation ensures that the system grows naturally from the world it observes, rather than forcing features into an artificial structure.#

=== 2.3.2 Real-Time System Design
[.hl-green]#The implementation uses Firebase's real-time capabilities with React state management for live bracket updates. Cloud Firestore's `onSnapshot()` listeners provide immediate data synchronization, while React's `useEffect()` and `useState()` hooks manage component state updates. This enables automatic bracket propagation when match results change.#

[.hl-green]#The real-time updating feature ensures that tournament brackets in the eSports web app stay synchronized across all users without requiring manual refreshes.#

=== 2.3.3 Tournament Algorithms
[.hl-green]#Single elimination bracket generation implements mathematical models using power-of-two calculations, bye allocations, and balanced binary tree structures. The system handles various tournament formats with algorithms for participant counting, round calculation `ceiling(log2 n)`, and fair seeding through random shuffling or rank-based sorting.#
