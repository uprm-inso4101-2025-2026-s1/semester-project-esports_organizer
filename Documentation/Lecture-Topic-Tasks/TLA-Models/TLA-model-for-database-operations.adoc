= TLA+ Model for Core Database Operations

== Acceptance Criteria

* TLA+ model checking successfully generated 327 states with 85 distinct states found. It managed complete state space exploration within defined constraints, and no safety property violations were detected. Execution was also completed in under a second. Insight into core operations is detailed below. 

== Findings Report

* After establishing basic functions like `CreateEvent`, `RemoveParticipant`, and `AddParticipant`, I moved onto `ToggleEventFinished`. The logic behind this function was to create an invariant that does not allow events to be toggled as finished if there are active participants in that event. When I went to revise the database logic, I realized there is no specific implementation for event lifecycle management.
* In `Events.js`, the current boolean property `finished` currently acts only as a placeholder for event status. There is no specific method designed for safe event status toggling. 

== Solution

* The Event class in the database code lacks a method to safely toggle the finished status with proper validation. It includes methods like addParticipant() and removeParticipant(), but no method to safely toggle the finished status while checking if participants exist. 
* Implement a method to the event class to safely toggle event status while ensuring there are no active users within it.
* Doing so would prevent both incomplete event management and poor user experience. 

== Model: 

----
---- MODULE MCDatabase ----
EXTENDS Naturals, Sequences, FiniteSets, TLC

CONSTANTS MaxEvents, MaxParticipants, EventNames, ParticipantIDs

VARIABLES events

\* State constraints
StateConstraint ==
    /\ Len(events) <= MaxEvents
    /\ \A i \in 1..Len(events): Len(events[i].participants) <= MaxParticipants

\* Event structure
EventRecord == [
    name: STRING,
    participants: Seq(STRING),
    maxSize: Nat,
    finished: BOOLEAN
]

\* Initial state (Empty database)
Init == events = << >>

\* Creates a new event
CreateEvent ==
    /\ Len(events) < MaxEvents
    /\ \E eventName \in EventNames :
        /\ ~\E i \in 1..Len(events) : events[i].name = eventName
        /\ events' = Append(events, [
            name |-> eventName, 
            participants |-> <<>>, 
            maxSize |-> MaxParticipants, 
            finished |-> FALSE
           ])

\* Adds participants to an event
AddParticipant ==
    /\ \E i \in 1..Len(events) :
        /\ events[i].finished = FALSE \* Blocks adding participants to a finished event
        /\ Len(events[i].participants) < events[i].maxSize
        /\ \E participant \in ParticipantIDs :
            /\ ~\E j \in 1..Len(events[i].participants) : events[i].participants[j] = participant
            /\ events' = [events EXCEPT ![i].participants = Append(events[i].participants, participant)]

\* Removes participants from an event
RemoveParticipant ==
    /\ \E i \in 1..Len(events) :
        /\ Len(events[i].participants) > 0
        /\ \E participant \in ParticipantIDs :
            /\ \E j \in 1..Len(events[i].participants) : events[i].participants[j] = participant
            /\ LET RemoveFromSeq(seq, elem) ==
                   [k \in 1..(Len(seq) - 1) |-> 
                    IF k < CHOOSE m \in 1..Len(seq) : seq[m] = elem
                    THEN seq[k]
                    ELSE seq[k + 1]]
               IN events' = [events EXCEPT ![i].participants = RemoveFromSeq(events[i].participants, participant)]

\* Toggles event status as finished
\* Can only mark an event as finished it has no participants
ToggleEventFinished ==
    /\ Len(events) > 0
    /\ \E i \in 1..Len(events) :
        /\ \/ /\ events[i].finished = TRUE  
              /\ events' = [events EXCEPT ![i].finished = FALSE]
           \/ /\ events[i].finished = FALSE
              /\ Len(events[i].participants) = 0
              /\ events' = [events EXCEPT ![i].finished = TRUE]

\* Next state (What can happen next)
Next == 
    \/ CreateEvent
    \/ AddParticipant
    \/ RemoveParticipant
    \/ ToggleEventFinished

\* Safety properties (Invariants and should never break)
EventCapacityLimit == 
    \A i \in 1..Len(events) : Len(events[i].participants) <= events[i].maxSize

NoDuplicateParticipants == 
    \A i \in 1..Len(events) : 
        \A j, k \in 1..Len(events[i].participants) : 
            j # k => events[i].participants[j] # events[i].participants[k]

NoParticipantsInFinishedEvents ==
    \A i \in 1..Len(events) :
        events[i].finished = TRUE => Len(events[i].participants) = 0

Invariant == 
    /\ EventCapacityLimit  
    /\ NoDuplicateParticipants
    /\ NoParticipantsInFinishedEvents

Spec == Init /\ [][Next]_<<events>>

====
----
